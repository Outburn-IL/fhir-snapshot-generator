import*as e from"fhir-package-explorer";import*as n from"fs-extra";import{createRequire as t}from"module";var i={};(()=>{i.n=e=>{var n=e&&e.__esModule?()=>e["default"]:()=>e;i.d(n,{a:n});return n}})();(()=>{i.d=(e,n)=>{for(var t in n){if(i.o(n,t)&&!i.o(e,t)){Object.defineProperty(e,t,{enumerable:true,get:n[t]})}}}})();(()=>{i.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n)})();if(typeof i!=="undefined")i.ab=new URL(".",import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/)?1:0,-1)+"/";var o={};const getNodeType=e=>{if(e.id.endsWith("[x]")){return"poly"}if(e.id===e.path&&e.base?.max&&(e.base.max==="*"||parseInt(e.base.max)>1)){return"array"}if(e.sliceName){if(e.slicing)return"resliced";return"slice"}return"element"};const buildTreeFromSnapshot=e=>{if(e.length===0){throw new Error("Snapshot array is empty")}const n=new Map;const makeSegments=e=>{const n=e.split(".");const t=n.map((e=>e.split(":")[0]));return{idSegments:n,pathSegments:t}};const createNode=(e,n)=>{const{idSegments:t,pathSegments:i}=makeSegments(e.id);const o=n||getNodeType(e);const r={id:e.id,path:e.path,idSegments:t,pathSegments:i,nodeType:o,children:[]};if(o==="array"||o==="poly"||o==="resliced"){const n={id:`${e.id}:@master@`,path:e.path,idSegments:[...t.slice(0,-1),t.at(-1)+":@master@"],pathSegments:i,nodeType:"slice",sliceName:"@master@",definition:e,children:[]};r.children.push(n)}else{r.definition=e}return r};const t=e[0];const i=createNode(t,"element");n.set(i.id,i);for(let t=1;t<e.length;t++){const i=e[t];const{idSegments:o}=makeSegments(i.id);const r=o.slice(0,-1).join(".");const s=n.get(r);if(!s){throw new Error(`Parent node not found for element ${i.id}`)}const a=createNode(i);if(s.nodeType==="array"||s.nodeType==="poly"||s.nodeType==="resliced"){const e=s.children.find((e=>e.sliceName==="@master@"));if(!e){throw new Error(`@master@ group missing under ${s.id}, should have been created immediately`)}e.children.push(a)}else if(s.nodeType==="slice"||s.nodeType==="element"){s.children.push(a)}else{throw new Error(`Unsupported parent node type: ${s.nodeType} for parent ${s.id}`)}n.set(a.id,a)}return i};const flattenTreeToSnapshot=e=>{const n=[];function visit(e){if(e.nodeType==="element"||e.nodeType==="slice"){if(!e.definition){throw new Error(`Node ${e.id} of type ${e.nodeType} is missing its definition`)}n.push(e.definition)}for(const n of e.children){visit(n)}}visit(e);return n};var x=e=>{var n={};i.d(n,e);return n};var y=e=>()=>e;const r=x({["FhirPackageExplorer"]:()=>e.FhirPackageExplorer});var external_fs_extra_x=e=>{var n={};i.d(n,e);return n};var external_fs_extra_y=e=>()=>e;const s=external_fs_extra_x({["default"]:()=>n["default"]});const a=t(import.meta.url)("path");var d=i.n(a);const applyDiffToTree=async(e,n,t,i)=>{const o=structuredClone(e);const r=new Map(n.map((e=>[e.id,e])));const s=new Set;if(o.definition&&o.definition.extension){delete o.definition.extension}function findMatchingNode(e,n){if(n.id===e){return n}if((n.nodeType==="array"||n.nodeType==="poly"||n.nodeType==="resliced")&&n.id===e){const e=n.children.find((e=>e.sliceName==="@master@"));if(e){return e}}for(const t of n.children){const n=findMatchingNode(e,t);if(n){return n}}return undefined}function getDefinitionTarget(e){if(e.definition){return e}if(e.nodeType==="array"||e.nodeType==="poly"||e.nodeType==="resliced"){const n=e.children.find((e=>e.sliceName==="@master@"));if(n?.definition){return n}}return undefined}async function expandNode(e,n){const o=e.definition?e:e.children.find((e=>e.sliceName==="@master@"));if(!o?.definition?.type||o.definition.type.length===0){if(i)i(`Node '${e.id}' has no type to expand.`);return}const r=o.definition.type[0].code;const s=await t(r);if(!s||s.length===0){throw new Error(`Snapshot for type '${r}' is empty or missing.`)}const a=s[0].id;const d=e.id;const c=rewriteSnapshotElements(s,d,a);const f=buildTreeFromSnapshot(c);const p=e.nodeType==="array"||e.nodeType==="poly"||e.nodeType==="resliced"?e.children.find((e=>e.sliceName==="@master@")):e;if(!p){throw new Error(`Cannot find insertion point for expanded children under node '${e.id}'.`)}p.children.push(...f.children);if(i){i(`Expanded node '${e.id}' with children: ${f.children.map((e=>e.id)).join(", ")}`)}for(const e of p.children){if(shouldExpandNode(e,n)){const t=e.definition?e:e.children.find((e=>e.sliceName==="@master@"));if(t?.definition?.type?.length){await expandNode(e,n)}}}}function shouldExpandNode(e,n){const t=e.id+".";for(const e of n.keys()){if(e.startsWith(t)){return true}}return false}function rewriteSnapshotElements(e,n,t){const i=t.endsWith(".")?t:t+".";const o=n.endsWith(".")?n:n+".";const replace=e=>e===t?n:e.startsWith(i)?o+e.slice(i.length):e;return e.map((e=>({...e,id:replace(e.id),path:replace(e.path)})))}for(const[e,n]of r.entries()){let t=findMatchingNode(e,o);let a=t?getDefinitionTarget(t):undefined;if(!t){const n=e.split(".");while(n.length>0&&!t){const i=n.join(".");const s=findMatchingNode(i,o);if(s){await expandNode(s,r);t=findMatchingNode(e,o);a=t?getDefinitionTarget(t):undefined;if(t)break}n.pop()}}if(t&&a){s.add(e);for(const e of Object.keys(n)){if(e==="constraint"){const e=a.definition.constraint||[];const t=n.constraint||[];a.definition.constraint=[...e,...t]}else if(e==="condition"){const e=a.definition.condition||[];const t=n.condition||[];const i=[...e,...t];a.definition.condition=Array.from(new Set(i))}else{if(n[e]!==undefined){a.definition[e]=n[e]}}}}else{const n=`Warning: Diff element with id '${e}' did not match any node in the tree.`;if(i){i(n)}else{console.warn(n)}}}return o};const c="./test/.test-cache";const getSnapshot=async(e,n)=>{console.log("getSnapshot",n);const t=n.startsWith("http:")||n.startsWith("https:");const i=t?await e.resolve({url:n,resourceType:"StructureDefinition"}):await e.resolve({id:n,resourceType:"StructureDefinition"});return i.snapshot.element};const applyDiffTest=async()=>{const e=await r.FhirPackageExplorer.create({cachePath:c,skipExamples:true,context:["fsg.test.pkg#0.1.0"]});const n=await e.resolve({id:"PatientIdentifierDeepDiff",resourceType:"StructureDefinition"});const t=await e.resolve({url:n.baseDefinition,resourceType:"StructureDefinition"});const i=buildTreeFromSnapshot(t.snapshot.element);const o=await applyDiffToTree(i,n.differential.element,(async n=>await getSnapshot(e,n)),(e=>console.log(e)));s["default"].writeJSONSync(d().join(e.getCachePath(),"PatientIdentifierDeepDiff-applied-tree.json"),o,{spaces:2});const a=flattenTreeToSnapshot(o);s["default"].writeJSONSync(d().join(e.getCachePath(),"PatientIdentifierDeepDiff-applied-snapshot.json"),a,{spaces:2});s["default"].writeJSONSync(d().join(e.getCachePath(),"PatientIdentifierDeepDiff-compare-snapshot.json"),n.snapshot.element,{spaces:2});console.log("Done!");console.log("Output written to:",e.getCachePath())};applyDiffTest().catch((e=>{console.error("Error during diff application:",e)}));